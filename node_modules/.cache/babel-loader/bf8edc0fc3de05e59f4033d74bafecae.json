{"ast":null,"code":"import { startWaapiAnimation } from './index.mjs';\nimport { createGeneratorEasing } from '../../../easing/utils/create-generator-easing.mjs';\nimport { browserNumberValueTypes } from '../../../render/dom/value-types/number-browser.mjs';\nimport { invariant } from '../../../utils/errors.mjs';\nimport { noop } from '../../../utils/noop.mjs';\nimport { secondsToMilliseconds, millisecondsToSeconds } from '../../../utils/time-conversion.mjs';\nimport { isGenerator } from '../../generators/utils/is-generator.mjs';\nimport { attachTimeline } from './utils/attach-timeline.mjs';\nimport { getFinalKeyframe } from './utils/get-final-keyframe.mjs';\nimport { setCSSVar, setStyle } from './utils/style.mjs';\nimport { supportsLinearEasing } from './utils/supports-linear-easing.mjs';\nimport { supportsPartialKeyframes } from './utils/supports-partial-keyframes.mjs';\nimport { supportsWaapi } from './utils/supports-waapi.mjs';\nconst state = new WeakMap();\n\nfunction hydrateKeyframes(valueName, keyframes, read) {\n  for (let i = 0; i < keyframes.length; i++) {\n    if (keyframes[i] === null) {\n      keyframes[i] = i === 0 ? read() : keyframes[i - 1];\n    }\n\n    if (typeof keyframes[i] === \"number\" && browserNumberValueTypes[valueName]) {\n      keyframes[i] = browserNumberValueTypes[valueName].transform(keyframes[i]);\n    }\n  }\n\n  if (!supportsPartialKeyframes() && keyframes.length < 2) {\n    keyframes.unshift(read());\n  }\n}\n\nconst defaultEasing = \"easeOut\";\n\nfunction getElementAnimationState(element) {\n  const animationState = state.get(element) || new Map();\n  state.set(element, animationState);\n  return state.get(element);\n}\n\nclass NativeAnimation {\n  constructor(element, valueName, valueKeyframes, options) {\n    const isCSSVar = valueName.startsWith(\"--\");\n    this.setValue = isCSSVar ? setCSSVar : setStyle;\n    this.options = options;\n    this.updateFinishedPromise();\n    invariant(typeof options.type !== \"string\", `animateMini doesn't support \"type\" as a string. Did you mean to import { spring } from \"framer-motion\"?`);\n    const existingAnimation = getElementAnimationState(element).get(valueName);\n    existingAnimation && existingAnimation.stop();\n\n    const readInitialKeyframe = () => {\n      return valueName.startsWith(\"--\") ? element.style.getPropertyValue(valueName) : window.getComputedStyle(element)[valueName];\n    };\n\n    if (!Array.isArray(valueKeyframes)) {\n      valueKeyframes = [valueKeyframes];\n    }\n\n    hydrateKeyframes(valueName, valueKeyframes, readInitialKeyframe); // TODO: Replace this with toString()?\n\n    if (isGenerator(options.type)) {\n      const generatorOptions = createGeneratorEasing(options, 100, options.type);\n      options.ease = supportsLinearEasing() ? generatorOptions.ease : defaultEasing;\n      options.duration = secondsToMilliseconds(generatorOptions.duration);\n      options.type = \"keyframes\";\n    } else {\n      options.ease = options.ease || defaultEasing;\n    }\n\n    this.removeAnimation = () => {\n      var _a;\n\n      return (_a = state.get(element)) === null || _a === void 0 ? void 0 : _a.delete(valueName);\n    };\n\n    const onFinish = () => {\n      this.setValue(element, valueName, getFinalKeyframe(valueKeyframes, this.options));\n      this.cancel();\n      this.resolveFinishedPromise();\n    };\n\n    if (!supportsWaapi()) {\n      onFinish();\n    } else {\n      this.animation = startWaapiAnimation(element, valueName, valueKeyframes, options);\n\n      if (options.autoplay === false) {\n        this.animation.pause();\n      }\n\n      this.animation.onfinish = onFinish;\n\n      if (this.pendingTimeline) {\n        attachTimeline(this.animation, this.pendingTimeline);\n      }\n\n      getElementAnimationState(element).set(valueName, this);\n    }\n  }\n\n  get duration() {\n    return millisecondsToSeconds(this.options.duration || 300);\n  }\n\n  get time() {\n    var _a;\n\n    if (this.animation) {\n      return millisecondsToSeconds(((_a = this.animation) === null || _a === void 0 ? void 0 : _a.currentTime) || 0);\n    }\n\n    return 0;\n  }\n\n  set time(newTime) {\n    if (this.animation) {\n      this.animation.currentTime = secondsToMilliseconds(newTime);\n    }\n  }\n\n  get speed() {\n    return this.animation ? this.animation.playbackRate : 1;\n  }\n\n  set speed(newSpeed) {\n    if (this.animation) {\n      this.animation.playbackRate = newSpeed;\n    }\n  }\n\n  get state() {\n    return this.animation ? this.animation.playState : \"finished\";\n  }\n\n  get startTime() {\n    return this.animation ? this.animation.startTime : null;\n  }\n\n  flatten() {\n    var _a;\n\n    if (!this.animation) return;\n    (_a = this.animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming({\n      easing: \"linear\"\n    });\n  }\n\n  play() {\n    if (this.state === \"finished\") {\n      this.updateFinishedPromise();\n    }\n\n    this.animation && this.animation.play();\n  }\n\n  pause() {\n    this.animation && this.animation.pause();\n  }\n\n  stop() {\n    if (!this.animation || this.state === \"idle\" || this.state === \"finished\") {\n      return;\n    }\n\n    if (this.animation.commitStyles) {\n      this.animation.commitStyles();\n    }\n\n    this.cancel();\n  }\n\n  complete() {\n    this.animation && this.animation.finish();\n  }\n\n  cancel() {\n    this.removeAnimation();\n\n    try {\n      this.animation && this.animation.cancel();\n    } catch (e) {}\n  }\n  /**\n   * Allows the returned animation to be awaited or promise-chained. Currently\n   * resolves when the animation finishes at all but in a future update could/should\n   * reject if its cancels.\n   */\n\n\n  then(resolve, reject) {\n    return this.currentFinishedPromise.then(resolve, reject);\n  }\n\n  updateFinishedPromise() {\n    this.currentFinishedPromise = new Promise(resolve => {\n      this.resolveFinishedPromise = resolve;\n    });\n  }\n\n  attachTimeline(timeline) {\n    if (!this.animation) {\n      this.pendingTimeline = timeline;\n    } else {\n      attachTimeline(this.animation, timeline);\n    }\n\n    return noop;\n  }\n\n}\n\nexport { NativeAnimation };","map":{"version":3,"sources":["/Users/damodhardattareddylikki/Desktop/Damodhar_portfolio/portfolio/node_modules/framer-motion/dist/es/animation/animators/waapi/NativeAnimation.mjs"],"names":["startWaapiAnimation","createGeneratorEasing","browserNumberValueTypes","invariant","noop","secondsToMilliseconds","millisecondsToSeconds","isGenerator","attachTimeline","getFinalKeyframe","setCSSVar","setStyle","supportsLinearEasing","supportsPartialKeyframes","supportsWaapi","state","WeakMap","hydrateKeyframes","valueName","keyframes","read","i","length","transform","unshift","defaultEasing","getElementAnimationState","element","animationState","get","Map","set","NativeAnimation","constructor","valueKeyframes","options","isCSSVar","startsWith","setValue","updateFinishedPromise","type","existingAnimation","stop","readInitialKeyframe","style","getPropertyValue","window","getComputedStyle","Array","isArray","generatorOptions","ease","duration","removeAnimation","_a","delete","onFinish","cancel","resolveFinishedPromise","animation","autoplay","pause","onfinish","pendingTimeline","time","currentTime","newTime","speed","playbackRate","newSpeed","playState","startTime","flatten","effect","updateTiming","easing","play","commitStyles","complete","finish","e","then","resolve","reject","currentFinishedPromise","Promise","timeline"],"mappings":"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","sourcesContent":["import { startWaapiAnimation } from './index.mjs';\nimport { createGeneratorEasing } from '../../../easing/utils/create-generator-easing.mjs';\nimport { browserNumberValueTypes } from '../../../render/dom/value-types/number-browser.mjs';\nimport { invariant } from '../../../utils/errors.mjs';\nimport { noop } from '../../../utils/noop.mjs';\nimport { secondsToMilliseconds, millisecondsToSeconds } from '../../../utils/time-conversion.mjs';\nimport { isGenerator } from '../../generators/utils/is-generator.mjs';\nimport { attachTimeline } from './utils/attach-timeline.mjs';\nimport { getFinalKeyframe } from './utils/get-final-keyframe.mjs';\nimport { setCSSVar, setStyle } from './utils/style.mjs';\nimport { supportsLinearEasing } from './utils/supports-linear-easing.mjs';\nimport { supportsPartialKeyframes } from './utils/supports-partial-keyframes.mjs';\nimport { supportsWaapi } from './utils/supports-waapi.mjs';\n\nconst state = new WeakMap();\nfunction hydrateKeyframes(valueName, keyframes, read) {\n    for (let i = 0; i < keyframes.length; i++) {\n        if (keyframes[i] === null) {\n            keyframes[i] = i === 0 ? read() : keyframes[i - 1];\n        }\n        if (typeof keyframes[i] === \"number\" &&\n            browserNumberValueTypes[valueName]) {\n            keyframes[i] = browserNumberValueTypes[valueName].transform(keyframes[i]);\n        }\n    }\n    if (!supportsPartialKeyframes() && keyframes.length < 2) {\n        keyframes.unshift(read());\n    }\n}\nconst defaultEasing = \"easeOut\";\nfunction getElementAnimationState(element) {\n    const animationState = state.get(element) || new Map();\n    state.set(element, animationState);\n    return state.get(element);\n}\nclass NativeAnimation {\n    constructor(element, valueName, valueKeyframes, options) {\n        const isCSSVar = valueName.startsWith(\"--\");\n        this.setValue = isCSSVar ? setCSSVar : setStyle;\n        this.options = options;\n        this.updateFinishedPromise();\n        invariant(typeof options.type !== \"string\", `animateMini doesn't support \"type\" as a string. Did you mean to import { spring } from \"framer-motion\"?`);\n        const existingAnimation = getElementAnimationState(element).get(valueName);\n        existingAnimation && existingAnimation.stop();\n        const readInitialKeyframe = () => {\n            return valueName.startsWith(\"--\")\n                ? element.style.getPropertyValue(valueName)\n                : window.getComputedStyle(element)[valueName];\n        };\n        if (!Array.isArray(valueKeyframes)) {\n            valueKeyframes = [valueKeyframes];\n        }\n        hydrateKeyframes(valueName, valueKeyframes, readInitialKeyframe);\n        // TODO: Replace this with toString()?\n        if (isGenerator(options.type)) {\n            const generatorOptions = createGeneratorEasing(options, 100, options.type);\n            options.ease = supportsLinearEasing()\n                ? generatorOptions.ease\n                : defaultEasing;\n            options.duration = secondsToMilliseconds(generatorOptions.duration);\n            options.type = \"keyframes\";\n        }\n        else {\n            options.ease = options.ease || defaultEasing;\n        }\n        this.removeAnimation = () => { var _a; return (_a = state.get(element)) === null || _a === void 0 ? void 0 : _a.delete(valueName); };\n        const onFinish = () => {\n            this.setValue(element, valueName, getFinalKeyframe(valueKeyframes, this.options));\n            this.cancel();\n            this.resolveFinishedPromise();\n        };\n        if (!supportsWaapi()) {\n            onFinish();\n        }\n        else {\n            this.animation = startWaapiAnimation(element, valueName, valueKeyframes, options);\n            if (options.autoplay === false) {\n                this.animation.pause();\n            }\n            this.animation.onfinish = onFinish;\n            if (this.pendingTimeline) {\n                attachTimeline(this.animation, this.pendingTimeline);\n            }\n            getElementAnimationState(element).set(valueName, this);\n        }\n    }\n    get duration() {\n        return millisecondsToSeconds(this.options.duration || 300);\n    }\n    get time() {\n        var _a;\n        if (this.animation) {\n            return millisecondsToSeconds(((_a = this.animation) === null || _a === void 0 ? void 0 : _a.currentTime) || 0);\n        }\n        return 0;\n    }\n    set time(newTime) {\n        if (this.animation) {\n            this.animation.currentTime = secondsToMilliseconds(newTime);\n        }\n    }\n    get speed() {\n        return this.animation ? this.animation.playbackRate : 1;\n    }\n    set speed(newSpeed) {\n        if (this.animation) {\n            this.animation.playbackRate = newSpeed;\n        }\n    }\n    get state() {\n        return this.animation ? this.animation.playState : \"finished\";\n    }\n    get startTime() {\n        return this.animation ? this.animation.startTime : null;\n    }\n    flatten() {\n        var _a;\n        if (!this.animation)\n            return;\n        (_a = this.animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming({ easing: \"linear\" });\n    }\n    play() {\n        if (this.state === \"finished\") {\n            this.updateFinishedPromise();\n        }\n        this.animation && this.animation.play();\n    }\n    pause() {\n        this.animation && this.animation.pause();\n    }\n    stop() {\n        if (!this.animation ||\n            this.state === \"idle\" ||\n            this.state === \"finished\") {\n            return;\n        }\n        if (this.animation.commitStyles) {\n            this.animation.commitStyles();\n        }\n        this.cancel();\n    }\n    complete() {\n        this.animation && this.animation.finish();\n    }\n    cancel() {\n        this.removeAnimation();\n        try {\n            this.animation && this.animation.cancel();\n        }\n        catch (e) { }\n    }\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve, reject) {\n        return this.currentFinishedPromise.then(resolve, reject);\n    }\n    updateFinishedPromise() {\n        this.currentFinishedPromise = new Promise((resolve) => {\n            this.resolveFinishedPromise = resolve;\n        });\n    }\n    attachTimeline(timeline) {\n        if (!this.animation) {\n            this.pendingTimeline = timeline;\n        }\n        else {\n            attachTimeline(this.animation, timeline);\n        }\n        return noop;\n    }\n}\n\nexport { NativeAnimation };\n"]},"metadata":{},"sourceType":"module"}